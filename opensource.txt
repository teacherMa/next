1.Retrofit

Retrofit是对okhttp的封装。主要提供的功能是通过动态代理，将Java的接口转化为实际请求方法，使我们能更方便的进行请求参数拼接、线程转化、处理返回值等操作。

Retrofit是如何将Java接口中的方法转化为请求的？
通过注解，将普通的Method转化为HttpServiceMethod。HttpServiceMethod通过CallAdapter将Method中的参数封装成HttpCall，通过Convert转化RawResponse。

Retrofit中的Call？
实现是HttpCall，HttpCall是对OkHttp.Call的封装。

2.OkHttp

Request：代表一个真正的请求，包含Url、Header、Body等内容，还包含一个CacheControl。

Call：一个已经准备好，能马上执行的请求，表示一对请求/响应。可以被取消。在Call中，由Dispatcher进行请求的分发与执行。Dispatcher默认同时最多进行60个请求，每个host最多同时进行5个请求。

拦截器：添加顺序是interceptors-几个自带的拦截器-networkInterceptors-CallServerInterceptor。
自带拦截器简介：
RetryAndFollowUpInterceptor：处理异常与重定向。
BridgeInterceptor：处理Header，处理gzip；将返回结果解析成需要的对象（不是Retrofit中的Bean对象，而是只包含ResponseCode和Body的基础Response对象）。
CacheInterceptor：处理缓存。需要注意的是，配置缓存需要服务端配合。
ConnectInterceptor：处理连接复用。连接可以复用的条件：Socket没有关闭、Socket输入输出没有关闭、Http链接没有关闭
CallServerInterceptor：处理真正的与服务的通信。


3.Glide

Glide.with(Context) 方法构造一个RequestManager来管理Request与Context的生命周期。不管什么对象，最终都转化为监听Fragment的生命周期。

RequestManager调用load后（默认调用asDrawable），得到一个RequestBuilder对象，之后的各种配置，比如placeHolder，diskCacheStrategy等，都是在建造者模式下进行的配置。

调用into()时，会将上一步配置的RequestBuilder对象转化为Request对象，然后与ImageView对象、线程池对象一起，构造成一个ImageViewTarget，传递给RequestManager进行加载。

RequestManager只负责管理Request的生命周期，如果Request可以启动，RequestManager会让RequestTracker来跟踪任务。RequestTracker负责跟踪、取消、重启正在进行中的，或者已经完成的，或者已经失败的请求。

请求真正开始的地方是Request.begin。调用begin后，会等到Target获取到真正尺寸了再开始加载请求。

加载请求是由Engine类完成的，缓存的逻辑就封装在Engine这一层，在真正加载之前，会先尝试从缓存中取资源，如果没取到，才会走解码、加载这一套流程；否则直接调用Callback传递缓存的资源。

缓存有两层，一层是Active的缓存，表示已经被使用的缓存，通过引用计数法判断是否被使用；一层是MemCache，MemCache使用了不同于Android的LRUCache算法。两层缓存的key都由Request的参数如尺寸大小、资源的URL、以及在RequestBuilder中设置的各种参数构造而成，缓存的Value是一个弱引用。

解码流程比较复杂，源码里将解码流程分成了几个阶段，第一个阶段是获取资源，第二个阶段是缓存，第三个阶段是资源转码；如果不需要缓存，则直接跳过第二个阶段。资源转码就是将资源转化为Bitmap等对象，Bitmap复用就是在这一步完成的。这些过程都是在Glide的线程池中完成的。

解码流程完成后，就会通知Request对象，将资源加载到Target中，通知Target对象的工作是在主线程完成的。

