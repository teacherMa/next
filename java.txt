Q：Java OOP的主要体现
A：
1.封装 隐藏实现细节，控制访问范围，模块化代码，解耦
2.继承 代码复用，代码分层
3.多态 同一个接口，不同的实现，override和overload

扩展

 1.比较抽象类和接口？
语法上的区别：单继承和多继承；是否能拥有默认方法（注意Java8的行为变更）；默认修饰符；在编译期间的处理。
设计思想上的区别：抽象类更像是在搭建框架，拥有默认的方法，所以可以自己做很多事情，同时如果要改动了，会更方便一点；抽象类还可以拥有自己的属性，是对属性和行为的抽象。
接口像是一个行为规范，比如设置监听，回调。
总的来说就是接口更轻量。

2.实现两个不同的接口，但是接口中有相同签名的方法怎么办？ 
如果签名完全一致，只需要重载一个方法即可，编译时不会有冲突。如果签名不一致，编译时会冲突。
为什么不会冲突呢？



Q：试比较XML、JSON、PB。
A：

PB：
1.去掉了key，改为1 2 3 4表示key（需要客户端和服务端定义好协议），带来数据量的减少。
2.序列化时采用TAG-VALUE-LENGTH的格式，序列化后排布紧凑；去掉了xml中<>和json中的{}，使数据量更少，反序列化时更快。
3.可读性较差，从反面来说，安全性较高。

XML：
1.xml天然支持属性，用来标记、描述。
2.xml可读性更好
3.格式统一？
4.现有框架支持部分解析
5.信息冗余，速度慢，占带宽

JSON：
1.JSON支持对象、数组、数字、字符串、布尔值，xml只有元素和属性，所以json更容易映射到数据结构。
2.在xml和PB之间做了可读和轻量的取舍


Q：Java中的运算符
A：
运算符优先级可以不考虑，正常人都会用括号。
==运算符比较的是数值，所以对于对象，会比较地址；对于基础类型对应的装箱类型，如果==两边类型不相等时，会有自动拆箱的操作。
关于乘法和除法：经过测试，使用位移来代替乘除带来的收益非常小。



Q：介绍一下Java中的异常机制
A：
Throwable的两个子类Exception和Error，二者都是可捕获的；Exception表示一种在程序级别应该被处理的错误，Error表示系统级别的错误。
直接继承自Exception的称为受检异常，必须在代码中处理；继承自RuntimException的称为非受检异常，不需要在代码中处理。
try-with-resource 原理：语法糖，编译器帮忙处理异常与资源关闭。

扩展：
1.为什么要设计异常？通过方法的返回值也可以告诉调用者，某个方法或者类运转是否正常。
检查返回值比较麻烦；函数调用栈一旦比较深，通过返回值来检查几乎不可能；通过抛出异常来中断当前程序，往往是因为当前环境下，已经处理不了这种问题，实际上是将问题转移到高层去处理。
比如说addView的BadTokenException，如果发生了这种异常，方法里是无法做出正确的判断的。

2.为什么要设计受检异常和非受检异常？
非受检异常通常是由调用者自己引起的错误，比如除了0，或者传递了空的引用；
受检异常通常表示底层或系统层面的错误，比如IO异常，网络异常；在程序设计时，可以看作设计者希望传递给调用者的信息：即使你使用正常，这里也可能产生错误，你必须处理它。

3.DefaultUncaughtExceptionHandler
需要注意的是，线程有一个字段是DefaultUncaughtExceptionHandler，也有一个静态变量是DefaultUncaughtExceptionHandler，二者都可以设置，后者用的比较多，一般通过Thread.setDefaultUncaughtExceptionHandler来设置，达到全局异常处理的目的。
原理：线程在创建时，会被归到一个线程组，发生异常时，Runtime会先调用该线程的实例UncaughtExceptionHandler方法，如果没有实例方法，就会调用线程组的相关方法，线程组会把异常当作参数来调用线程相关的静态类的方法。

4.如果想要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，可以在异常的构造器中传入一个 cause（因由）对象作为参数。
这个 cause 就用来表示原始异常，这样通过把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。


Q：介绍一下Java中的泛型
A：

1.
通常情况下，一个编译器处理泛型有两种方式：
Code specialization。在实例化一个泛型类或泛型方法时都产生一份新的目标代码（字节码or二进制代码）。例如，针对一个泛型list，可能需要 针对string，integer，float产生三份目标代码。
Code sharing。对每个泛型类只生成唯一的一份目标代码；该泛型类的所有实例都映射到这份目标代码上（所以共享static变量），在需要的时候执行类型检查和类型转换。
Code specialization属于真正意义上的泛型，会带来代码膨胀的后果，C++在用；Code sharing可以看作是伪泛型，Java在用。

2.
常用的三种：泛型类、泛型方法、泛型接口。当泛型类中存在泛型方法且二者都定义了自己的泛型参数时，泛型方法的参数以方法定义的参数为准。
类型擦除：在编译期间，泛型参数会被替换成Object。可以通过使用extends来指定泛型类、泛型方法、泛型接口的泛型参数，使泛型参数在类型擦除时，被擦除成extends指定的上界。
限定符：? extends xxx、? super xxx  用在非声明泛型参数的地方。

3.
考虑这样一种情况：某个泛型类的两个实例分别使用具有继承关系的两个类作为泛型参数，这两个实例没有继承关系。如下：
private class Fruits {
}
private class Apple extends Fruits {
}
class Box<T> {
}
Box<Apple> 和 Box<Fruits> 不存在继承关系。

4.
泛型中的多态：
桥接模式与强制类型转化。

5.泛型擦除带来的问题
无法实例化泛型对象，无法创建泛型数组，无法对泛型类使用instanceof关键字，必须使用强制类型转化。


Q：Object的方法有哪些？
A：
hashCode equals toString getClass notify notifyAll clone wait finalize


Q：String StringBuffer StringBuilder
A：
String的内部实现。
 + 运算符重载原理：自动生成StringBuilder。这是编译器优化出来的，如果在for循环里进行String的拼接，每次循环都会生成StringBuilder（猜测是因为一行语句优化一次），所以有以下结论：
String是不可变的，所以直接用+拼接字符串时会生成很多对象，用StringBuilder 效率更高。StringBuilder 内部有一个字节数组，append的时候就是往数组里添加元素，需要的时候会扩容。StringBuffer 和StringBuilder原理一致，但是加了Sync关键字，线程安全。


Q：HashMap、HashTable、HashSet
A：



Q：Java中的引用
A：
强引用：日常使用的引用，GC时不会被回收，即使OOM也不会被回收。
软引用：GC时如果内存不足，可能会被回收，在OOM之前一定被回收；常用于对内存敏感的缓存。
弱引用：一旦发生GC，就会被回收。
虚引用：必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。可以根据这个特点判断对象是否要被回收。


Q：介绍一下Android中的注解
A：
Android的注解来源于Java中的注解。注解是一种元数据，是一种源码层面的、在代码中添加信息的形式；添加的信息一般通过反射来处理。
几个关键点：Target Retention，Inherited只有在extends是生效，在Implement中不生效；注解通过动态代理类实现。
Android通过指定注解处理类，来达到处理项目中注解的目的。


Q：Java中的继承
A：
1.单继承
2.子类拥有父类的所有接口和字段，但是private方法不是接口，static方法不是接口，构造函数其实是隐式static方法。
3.子类中其实拥有一个父类的对象，所以子类必须调用父类的构造方法。


Q：Thread与Process
A：
Process是操纵系统进行资源调度的基本单位，Process之间不共享内存信息；进程切换开销比线程大。
Thread是处理器调度和分派的基本单位，不同Thread共享内存空间，但是Thread有自己的程序计数器，寄存器和栈；多线程切换开销小，但是仍然有开销，开销来自寄存器内容的保存与读取、程序栈的保存与读取。
Thread状态：创建 运行 等待时间片的阻塞 sleep引起的等待 死亡
终止一个Thread：方法运行完自然结束、stop（不建议）、interrupt

死锁：
直接原因：1资源不足；2.资源分配不合理；3.程序流程有问题
必要条件-1.资源是有限的；2.资源无法共享；3.已经分配的资源无法被剥夺；4.循环等待
检测：一种简单的方法：建立一张图，图的元素是各个资源需求方，同时元素拥有一些资源和它需要的资源两个信息，如果A元素拥有B元素所需要但是B元素又没有的资源，那么B和A之间建立一条有向的链接，最后分析这张图中是否有闭环就可以了。


Q：Java中的线程池
A：
Executor - 基础接口，定义execute方法
ExecutorServices - 继承Executor，提供shutDown、submit、invokeAll等方法
Executors - 提供了一系列获取ExecutorServices的方法
ThreadPoolExecutor - 线程池
ScheduledThreadPoolExecutor - 带延时功能的线程池

submit时发生的事情：
1.检查当前运行的线程数，如果小于corePoolSize则创建新线程，提交新任务，成功则返回，否则执行2
2.尝试向等待队列中添加任务，添加成功后会进行一次double-check，目的是检查是否有在添加新任务后，现有的全部都死亡了或者线程池已经被shutDown了。如果现有的全部都死亡了，需要添加新的线程。如果添加失败，执行3
3.检查当前运行的线程数，如果小于maximumPoolSize则创建新线程，提交新任务
如果以上三个都失败，则执行拒绝策略。



Q：多线程不安全的原因
A：
几个关键点
1.缓存一致性：主内存和CPU高速缓存之间的一致性问题。从硬件层面，已经有协议能保证缓存一致性的问题了。由于Java是跨平台的，所以还需要从Java内存模型上去考虑缓存一致性的问题。

2.可见性：为了解决缓存一致性的问题，Java提供了volatile关键字来保证缓存一致性，即某个线程修改了volatile修饰的变量的值，会马上将修改后的值写回到主内存，同时刷新其他CPU缓存中的变量的值。
Voatile原理是内存屏障，内存屏障会提供3个功能：
它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
它会强制将对缓存的修改操作立即写入主存；
如果是写操作，它会导致其他CPU中对应的缓存行无效。

3.原子性：一条指令就能完成的操作称为原子操作，变量get和set操作是原子的。但是比如++、-- 这种操作就不是原子的，因为包含{读值、++/--、写入}三个操作。Atomic类提供了一系列的原子操作。

4.锁
临界区概念
乐观锁 CAS算法，执行的时候不会阻塞，典型应用Atomic
悲观锁 synchronized，有锁的线程执行时，其他线程会阻塞
ReentrantLock 与Condition 更细粒度的锁，典型应用如生产者消费者模型

5.Streams和CompletableFutures



Q：JVM内存模型
A：
分五大块：方法区、堆区、JVM虚拟机栈、本地方法栈、程序计数器
由多线程访问共享变量引起的问题以及线程有自己的堆栈可以推断出：方法区和堆区是线程之间共享的，JVM虚拟机栈和本地方法栈、程序计数器是每个线程独有的。

程序计数器：记录程序执行到了哪一行，无OOM
虚拟机栈：存放的是Java方法的栈帧。每个栈帧记录了方法局部变量表、操作栈、动态链接、方法出口等信息。方法执行时栈帧会入栈，执行结束会出栈。如果某个方法里有内部类引用了局部变量，会要求把局部变量声明为final的，这样在栈帧出栈了之后，才能继续在常量区访问到引用的变量。（Java8隐式final）
如果嵌套调用方法，会有StackOverflowError
本地方法栈：和虚拟机栈类似，但是存放的时native方法
方法区：常量、静态变量、被加载的类信息、运行时常量池
堆区：存放对象的实例（不是引用）和数组。GC的主要区域，存在OOM

垃圾回收：
分两大块：
1.如何找到垃圾：引用计数法-存在循环依赖的问题；根搜索算法：虚拟机栈中引用的对象、方法区中常量和静态变量引用的对象、JNI引用的对象。以上四种对象可以当作GC-Root。
2.如何回收垃圾：
标记清除-容易造成不连续的内存空间；
标记复制-可用空间只有50%，空间利用率低；
标记整理-每次都要移动，效率低；
多数虚拟机综合以上三个，使用分代回收的方法：新生代使用标记复制，一块80%的eden区，两块10%的survivor区；老年代使用标记整理。


Q：Java中的类加载机制
A：
分七步：加载、验证、准备、解析、初始化、使用、卸载。其中加载、验证、准备、初始化、卸载五步的顺序是确定的。

加载：1.通过类的全限定名称来获取二进制流
2.将二进制流代表的静态对象转化为运行时数据结构
3.在堆区生成一个代表这个类的Class对象，作为方法区数据访问的入口

验证：1.字节流格式验证-是否符合class文件规范
2.语法验证

准备：为static变量分配内存并赋初始化值。需要注意的是，只为static变量分配内存，并且赋值为初始化的值，如0，false；只有static final变量才会被赋值为=右边指定的值。

解析：。。。太难了

初始化：初始化阶段是真正执行类中程序员自定义静态代码的阶段。
初始化时会执行<clinit>方法。clinit方法不同于类的构造方法<init>:
clinit方法由编译器生成的，收集了类中所有的static变量赋值语句以及static代码块的方法；
父类的clinit方法会优于子类的clinit方法执行；

使用：xxx
卸载：xxx

类加载器ClassLoader
从虚拟机的角度，分为两类，第一类是启动类加载器BootStrapClassLoader，由C++实现，属于JVM的一部分，负责加载<JAVA_HOME>\lib目录下的内容；第二类就是其他所有的类加载器。
从开发人员角度，分为四类，第一类是BootStrapClassLoader，同上；第二类是扩展类加载器，加载<JAVA_HOME>\lib\ext目录下的内容；第三类是应用程序加载器，加载Classpath路径下的内容；第四类就是自定义类加载器。
双亲委派模式：加载类时，优先使用父类加载器去加载。这只是一个建议，并不是强制约束。遵循这个建议可以保证同一个类始终由同一个类加载器加载。


























