四大组件

1.Service

Service生命周期：
startService，启动一个服务。如果Service没有创建，会先调用onCreate，然后调用onStartCommand；如果创建了，则只调用onStartCommand。
bindService，绑定一个客户端到服务。如果Service没有创建，会根据传入的flag决定是否创建，如果创建Service，就会调用onCreate。如果不创建，bind会进入到pending状态，等到service创建时，再调用Service的onBind；之后客户端再调用bindService，Service的onBind也不会被调用了。
stopService，停止一个服务。如果没有客户端绑定到服务，会走onDestroy；之后再调用startService或者bindService，就会再走onCreate。如果有客户端绑定到服务，则stopService不会生效。
unbindService，客户端与服务端接触绑定。如果service没有被bind过，调用此方法会导致异常。反之会先走onUnbind，如果service只被绑定过，service会在所有bind的客户端调用了unbind之后，自动走onDestriy；如果service被启动过，则unbindService不会造成service走destory。

service的生命周期，onCreate和onDestroy是一套，因为它不接收Intent参数；onStartCommand、onBind、onUnbind等接收Intent参数的是一套。这两套互相嵌套。

普通服务与后台服务：
通过startService的方式启动的服务是普通服务；通过startServiceForeground启动的服务是前台服务，前台服务必须为状态栏提供通知，并且启动前台服务需要相应的权限，前台服务优先级较高。

参考链接：https://developer.android.com/guide/components/services#CreatingBoundService

IntentService：简化的Service，在子线程中使用队列来处理事务，处理完毕会自动stopSelf。
JobIntentService：Android8.0及以上为了避免系统对后台service的限制提供的类，使用Job而不是Service去处理任务，内部使用AsyncTask来实现在子线程中按照队列的形式处理事务。

与Service的通信：

一般通过startService时传递的intent传递信息即可；还可以通过bindService时得到的Binder实现client与Service之间的通信。

跨进程通信基于Binder机制。Binder实现了IBinder接口。

通过Messenger的通信：Messenger实际上也是基于Binder的通信，但是对Binder做了包装。

通过AIDL的通信：AIDL全称AndroidInterfaceDefineLanguage，Android接口定义语言。AIDL的意义在于，我们只需要在AIDL文件中定义一些关键的接口，AS就能帮我们生成一些复杂的代码。AIDL实际上还是对Binder的封装。

以client调用service为例，首先写一个xxx.aidl，会生成一个对应的Java接口文件xxx.java，service实现这个文件中的Stub抽象类即可。

c-s连接如何建立：
通过bindService调用，service需要在onBinder方法中返回一个Binder对象，Stub本身已经继承了Binder，所以Stub可以当作Binder直接用于方法的返回值。
但是实际上，这个Binder对象不会直接被用做client的ServiceConnection.onServiceConnected的参数，因为是不能直接跨进程传递对象的，client实际收到的是一个BinderProxy。
client在收到BinderProxy后，通过xxx.Stub.asInterface将BinderProxy对象转化为xxx接口。调用asInterface时，返回的是xxx$Stub$Proxy对象，client调用xxx.java中的方法时，实际上调用的是Proxy对象中的方法。
Proxy被调用方法时，会先将方法参数序列化，然后通过IBinder.transact跨进程传递到service。
IBinder.transact跨进程传递到service后，service的Binder.onTransact方法会被调用，然后会调用Stub中的方法。

AIDL中的in out 与 inout
为了表示简单一点，将一个方法调用的发起端称为client，实际被调用端称为service。
in表示数据从client流向service，用in修饰的数据需要实现Parcelable，在方法调用的过程中，会被调用writeToParcel和CREATOR.createFromParcel。
out表示数据从service流向client，用out修饰的数据必须有一个名为readFromParcel的public方法。
inout表示数据先从client流向service，再从service流向client。inout需要实现Parcelable接口和必须有一个名为readFromParcel的public方法。
基本数据类型默认且强制为in。

Binder通信是同步通信。
虽然Binder通信时，client与service是在不同的线程中，但是二者是同步调用。通过查看aidl生成的java代码，可以知道client发起调用请求后，会在拿到service处理结果后再进行下一步的操作。





2.Activity

Activity启动流程

通过startActivity启动，初始的准备工作主要是ActivityStack，ActivityStackSupervisor，之后会跨进程调用ActivityThread中的方法。
几个关键点：
Instrumentation类：负责Application、Activity的创建，以及调用相应的生命周期方法。
启动activity之前需要创建Application：创建context-attachContext-onCreate
ApplicationThread.handleLaunchActivity：先调用Instrumentation创建activity->为activity设置主题等内容->Activity.attach->Activity.onCreate->handleResumeActivity。

Activity.attach：PhoneWindow在此初始化，WindowManager在此初始化。

onCreate、onStart、没什么特殊的

ApplicationThread.handleResumeActivity：这个方法里最主要的是addDecorView，并设置DecorView的ViewRootImpl，设置完之后还会调用WindowManager.updateViewLayout去更新DecorView。
更新DecorView时已经到了下一帧，所以在onResume中无法获取View的宽度和高度。


Activity生命周期：
                      ____________
                     |            |
onCreate->onStart->onResume->onPause->onStop->onDestroy.
            |__________onRestart_________|

onCreate与onDestroy：Activity创建和销毁，在ActivityThread中可以看到，确实是Activity创建之后，就会调用onCreate。

onStart与onStop：Activity是否可见。比如弹出一个新的Activity，如果新的Activity是透明的，那么原Activity就还是可见，不会调用onStop；如果不是透明的，则会调用onStop。需要注意的是，activity是否透明需要在theme中指定才有上述结论，如果在onCreate中设置window的background为透明色，上述结论不成立。原因是
startActivity时会解析theme，才能决定原Activity是否要stop。

onResume与onPause：Activity是否在前台。

弹Dialog：不会走生命周期。
切前后台：走stop和start。

JVM、ART、与Dalvik：
JVM执行的是.class代表的java字节码。
Dalvik执行的是.dex代表的Dalvik字节码。
ART是在Dalvik基础上进行的改进，应用第一次安装时会将部分字节码转化为机器码，之后再执行，就不需要再次转化，提升了速度。



JNI相关

全称是JavaNativeInterface，实现Java和Native交互

静态注册与动态注册：
Java类中写一个native方法，然后用javah生成一个Java_packagename_classname的jni方法，在Java层第一次调用native方法时，会根据Java_packagename_classname去找对应的jni方法，找到之后，就保存一个方法指针，下次调用native方法时，就直接根据方法指针去找对应的jni方法了，这就是静态注册。静态注册的主要问题在于，需要用javah来生成方法，方法名特别长；第一次找方法指针时耗时比较长。
Java类中写一个native方法，在jni代码中创建对应的jni方法，然后创建对应的结构体JNINativeMethod，结构体中包含native方法的名称、native方法的签名、和要绑定的jni方法。然后调用AndroidRuntime::registerNativeMethods，就可以进行动态绑定。

数据结构转换：
基本数据类型。Java.void->JNI.void，其他的基本数据类型就是在前面加j，比如jboolean，jint
引用类型。Object-jobject，Class-jclass，全都是加j

方法签名：
因为java方法存在overload，所以通过方法名称无法唯一确定一个函数，必须通过方法签名。方法签名由 "(参数列表签名)返回值签名 构成，比如(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;)V
可以通过javap 查看方法签名

JNIEnv：
一个指向所有JNI方法的指针，只在当前线程有效，不能跨线程传递。

JavaVM：
Java虚拟机在native层的代表，可以通过attachCurrentThread获取当前线程的JNIEnv实例


触摸事件

Activity.dispatchTouchEvent->Window.dispatchTouchEvent->DecorView.dispatchTouchEvent->ViewGroup.dispatchTouchEvent.
ViewGroup.dispatchTouchEvent：如果可以拦截，先调用onInterceptTouchEvent判断是否拦截，如果拦截则交给自己处理。如果不拦截则调用子View的dispatchTouchEvent。
View.dispatchTouchEvent：先交给TouchListener处理，如果TouchListener返回false则交给touchEvent方法处理。

ViewGroup.dispatchTouchEvent：是否拦截触摸不让其向下传递。子View可以通过requestDisallowInterceptTouchEvent设置flag，不让父View拦截触摸事件。这个flag会一直向上传递；这个flag对DOWN事件无效，因为ViewGroup会在DOWN事件时重置flag。

如果没人处理触摸事件，最终处理触摸事件的是Activity.onTouchEvent。



自定义View

onMeasure：主要知识点在于MeasureSpec。MeasureSpec是一个包含了测量模式与测量尺寸的int。子View的测量由父View的测量模式+子View的测量模式组成，具体可以查看ViewGroup中的getChildMeasureSpec方法。
onLayout：没啥好说的。
onDraw：绘制。高级动效都基于Paint的一些模式的设置和Path的使用。



性能优化：

内存工具:
LeakCanary原理：
1.监听：通过registerLifecycle的形式监听Fragment或Activity的生命周期。
2.检测：在生命周期结束后，通过检测引用队列中是否有对应的弱引用，判断是否发生了泄漏。
3.dump：suqare的另一个库 haha
存在的问题：只能检测Activity和Fragment，不能检测Service。

响应时间:
1.可以通过AS自带工具。
2.BlockCanary：原理是在主线程的Looper分发消息前后打日志，然后dump堆栈。有缺陷，无法精准定位哪里卡顿。

ANR:
adb bugreport 会生成一个zip，解压后找最大的文件，然后查找VM TRACES AT LAST ANR，即可定位到ANR的位置。



视图层级

关键点：Activity、Window、PhoneWindow、DecorView、WindowManager、WindowManagerService、WindowSession、ViewRootImpl。

一个Activity拥有一个Window，Activity中的Window初始化于Activity.attach。Window是一个抽象类，其实现是PhoneWindow。PhoneWindow在Window的基础上扩展了一个DecorView的概念，DecorView顾名思义，是一个装饰View，由ToolBar与Content组成。DecorView想要显示出来，必须通过WindowManager.addView依附ViewRootImpl，
这一步发生在ActivityThread.handleResumeActivity。

WindowManager是一个抽象类，其实现是WindowManagerImpl，但是WindowManagerImpl也只是对WindowManagerGlobal的Wrapper。WindowManager并不具有管理Window的功能，必须通过ViewRootImpl通过IPC与Session通信，Session再调用WindowManagerService相应的方法。

WindowManagerService是服务端真正管理Window的对象。WMS管理的对象是IWindow，IWindow在客户端对应ViewRootImpl中的一个W实例。所以WindowManager、WindowManagerService这些和Window以及PhoneWindow没有关系，与ViewRootImpl有关系。

ViewGroup.addView和WindowManager.addView区别很大。

前者只是将View添加到了子View数组中，然后刷新视图；

后者会创建一个新的ViewRootImpl，将新的ViewRootImpl纳入WindowManager的管理范围，再调用ViewRootImpl.setView将View设置为ViewRootImpl的根View，同时将ViewRootImpl设置为View的parent。
ViewRootImpl都有一个W对象，在ViewRootImpl中，setView会调用Session.addToDisplay方法将W对象当作Window添加到服务端，addToDisplay方法最终会调用WindowManagerService的addWindow方法。
添加成功后，ViewRootImpl就会调用setFrame方法开始绘制自己。



动画原理：

1.普通动画：Transformation类中存储了alpha、matrix等信息，动画开始后，每次刷新时调用动画的applyTransformation，动画根据时间来判断进度，从而更新Transformation中相关值，然后在draw的时候，将相应的Transformation作用于canvas。
2.属性动画：向Choreographer注册callback来刷新，刷新的时候根据给定的初始值、最终值算出当前位置，进而算出当前的值，然后通过反射更改属性的值。
3.帧动画：将资源解析成很多个Bitmap，然后向Choreographer注册callback来刷新，每次刷新的时候，根据当前时间draw出来当前要使用的Bitmap。因为一开始会将所有Bitmap都解析出来，所以有可能存在内存问题。

Choreographer：
管理视图刷新、提供一种监听处理底层V-SYNC信号的方法的类。有四种类别：Animation、Input、Transversal、Commit。
实际上每次更新视图，都是在ViewRootImpl中向ChoreoGrapher注册callback，然后等V-SYNC信号来了才能刷新（这就属于Transversal类型）。
还可以通过向Choreographer注册监听来检测是否有掉帧的现象。



消息机制：
Handler、Message、MessageQueue、ThreadLocal、HandlerThread、IdleHandler





检测是否被Root：
1.检测data/data目录的权限，正常手机该目录只有读权限。
2.检测是否已经安装superSu
3.执行命令行su指令：Runtime.getRuntime().exec("su")。


Fragment生命周期：
onAttach-onCreate-onCreateView-onStart-onResume-onPause-onStop-onDestriyView-onDestroy-onDetach


webview



组件化



屏幕适配



图片加载：
1.Bitmap嗅探：Decode时可以传一个option，只嗅探Bitmap的宽度和高度，再根据Target的宽度和高度算出scale（必须为1或者2的整数次幂），就可以减少Bitmap的大小。
2.Bitmap复用：Bitmap.createBitmap时可以传一个Origin的Bitmap，或者在BitmapFactory的Option中指定inBitmap，4.4以上复用Bitmap不再要求被复用的Bitmap与即将被加载的Bitmap宽高必须一致，只要求前者大于后者即可。
3.减少Bitmap的内存消耗：Config中颜色的选择，长图加载时使用BitmapRegionDecdoer



热修复：
热修复从原理上来说可以分两种，一种是native层面的，一种是Java层面的。
native层面的一般是替换JVM中方法的指针，从而达到hook的目的；
Java层面的是利用多dex的特性，Hook了ClassLoader.pathList.dexElements[]。因为ClassLoader的findClass是通过遍历dexElements[]中的dex来寻找类的，越靠前的Dex优先被系统使用。